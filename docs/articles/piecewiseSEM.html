<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>piecewiseSEM: Piecewise Structural Equation Modeling in R • piecewiseSEM</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="piecewiseSEM: Piecewise Structural Equation Modeling in R">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">piecewiseSEM</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">2.0.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/piecewiseSEM.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>piecewiseSEM: Piecewise Structural Equation Modeling in R</h1>
                        <h4 class="author">Jonathan S. Lefcheck</h4>
            
            <h4 class="date">2018-06-20</h4>
      
      
      <div class="hidden name"><code>piecewiseSEM.Rmd</code></div>

    </div>

    
    
<p>Structural equation modeling (SEM) is among the fastest growing statistical techniques in ecology and evolution, and provides a new way to explore and quantify ecological systems. SEM unites multiple variables in a single causal network, thereby allowing simultaneous tests of multiple hypotheses. The idea of causality is central to SEM as the technique implicitly assumes that the relationships among variables represent causal links. Because variables can be both predictors and responses, SEM is also a useful tool for quantifying both direct and indirect (cascading) effects.</p>
<p>Piecewise SEM (or confirmatory path analysis) expands upon traditional SEM by introducing a flexible mathematical framework that can incorporate a wide variety of model structures, distributions, and assumptions. These include: interactions and non-normal responses, random effects and hierarchical models, and alternate correlation structures (including phylogenetic, spatial, and temporal).</p>
<p>This release is version 2.0 of the package and contains substantial updates to both the syntax and the underlying calculations. All functions have been replaced and rewritten from the ground up.</p>
<p>The first part of this vignette will briefly introduce the concepts behind piecewise SEM. The second part will introduce the new syntax using a worked example. The final part will briefly compare the old and new versions of the package.</p>
<div id="an-introduction-to-structural-equation-modeling" class="section level2">
<h2 class="hasAnchor">
<a href="#an-introduction-to-structural-equation-modeling" class="anchor"></a>1. An Introduction to Structural Equation Modeling</h2>
<p>Broadly, structural equation modeling (SEM) unites a suite of variables in a single network. They are generally presented using box-and-arrow diagrams denoting directed (causal) relationships among variables:</p>
<div class="figure">
<img src="https://github.com/jslefche/jslefche.github.io/blob/master/img/example_sem.jpg?raw=true" alt="1.1 Example SEM"><p class="caption">1.1 Example SEM</p>
</div>
<p>Those variables that exist only as predictors in the network are referred to as exogenous, and those that are predicted (at any point) as endogenous. Exogenous variables therefore only ever have arrows coming out of them, while endogenous arrows have arrows coming into them (which does not preclude them from having arrows come out of them as well). This vocabulary is important when considering some special cases later.</p>
<p>In traditional SEM, the relationships among variables (i.e., their linear coefficients) are estimated simultaneously in a single variance-covariance matrix. This approach is well developed but can be computationally intensive (depending on the sizes of the v-cov matrix) and additionally assumes independence and normality of errors, two assumptions that are generally violated in ecological research.</p>
<p>Piecewise structural equation modeling (SEM), also called confirmatory path analysis, was proposed in the early 2000s by Bill Shipley as an alternate approach to traditional variance-covariance based SEM. In piecewise SEM, each set of relationships is estimated independently (or locally). This proces decomposes the network into the corresponding simple or multiple linear regressions for each response, each of which are evaluated separately, and then combined later to generate inferences about the entire SEM. This approach has two consequences: 1. Increasingly large networks can be estimated with ease compared to a single vcov matrix (because the approach is modularized), and 2. Specific assumptions about the distribution and covariance of the responses can be addressed using typical extensions of linear regression, such as fixed covariance structures, random effects, and other sophisticated modeling techniques.</p>
<p>Unlike traditional SEM, which uses a <span class="math inline">\(\chi^2\)</span> test to compare the observed and predicted covariance matrices, the goodness-of-fit of a piecewise structural equation model is obtained using ‘tests of directed separation.’ These tests evaluate the assumption that the specific causal structure reflects the data. This is accomplished by deriving the ‘basis set,’ which is the smallest set of independence claims obtained from the SEM. These claims are relationships that are <em>un</em>specified in the model, in other words paths that could have been included but were omitted because they were deemed to be biologically or mechanistically insigificant. The tests ask whether these relationships can truly be considered independent (i.e., their association is not statistically significant within some threshold of acceptable error, typically <span class="math inline">\(\alpha\)</span>=0.05) or whether some causal relationship may exist as indicated by the data.</p>
<p>For instance, the preceding example SEM contains 4 specified paths (solid, black) and 2 unspecified paths (dashed, red), the latter of which constitute the basis set:</p>
<div class="figure">
<img src="https://github.com/jslefche/jslefche.github.io/blob/master/img/sem_missing_paths.jpg?raw=true" alt="1.2 Missing Paths"><p class="caption">1.2 Missing Paths</p>
</div>
<p>In this case, there are two relationships that need to be evaluated: <code>y3</code> and <code>x1</code>, and <code>y3</code> and <code>y2</code>. However, there are additional influences on <code>y3</code>, specifically the directed path from <code>y2</code>. Thus, the claims need to be evaluated for ‘conditional independence,’ i.e. that the two variables are independent <em>conditional</em> on the already specified influences on both of them. This also pertains to the predictors of <code>y2</code>, including the potential contributions of <code>x1</code>. So the full claim would be: <code>y2 | y3 (y1, x1)</code>, with the claim of interest separated by the <code>|</code> bar and the conditioning variable(s) following in parentheses.</p>
<p>As the network grows more complex, however, the independence claims only consider variables that are <em>immediately ancestral</em> to the primary claim (i.e., the parent nodes). For example, if there was another variable predicting <code>x1</code>, it would not be considered in the independence claim between <code>y3</code> and <code>y2</code> since it is &gt;1 node away in the network.</p>
<p>The independence claims are evaluated by fitting a regression between the two variables of interest with any conditioning variables included as covariates. Thus, the claim above <code>y2 | y3 (y1, x1)</code> would be modeled as <code>y3 ~ y2 + y1 + x1</code> . These regressions are constructed using the same assumptions about <code>y3</code> as specified in the actual structural equation model. So, for instance, if <code>y3</code> is a hierarchically sampled variable predicted by <code>y1</code>, then same hierarchical structure would carry over to the test of directed separation of <code>y3</code> predicted by <code>y2</code>.</p>
<p>The P-values of the conditional independence tests are then combined in a single Fisher’s C statistic using the following equation:</p>
<p><span class="math display">\[C = -2\sum_{i=1}^{k}ln(p_{i})\]</span></p>
<p>This statistic is <span class="math inline">\(\chi^2\)</span>-distributed with 2k degrees of freedom, with k being the number of independence claims in the basis set.</p>
<p>Shipley (2013) also showed that the the C statistic can be used to compute an AIC score for the SEM, so that nested comparisons can be made in a model selection framework:</p>
<p><span class="math display">\[AIC = C + 2K\]</span></p>
<p>where K is the likelihood degrees of freedom. A further variant, <span class="math inline">\(AIC_c\)</span>, can be obtained by adding an additional penalty based on sample size:</p>
<p><span class="math display">\[AIC_c = C + 2K\frac{n}{(n - K - 1)}\]</span></p>
<p>The <code>piecewiseSEM</code> package automates the derivation of the basis set and the tests of directed separation, as well as extraction of path coefficients based on the user-specified input.</p>
</div>
<div id="an-example-using-piecewisesem" class="section level2">
<h2 class="hasAnchor">
<a href="#an-example-using-piecewisesem" class="anchor"></a>2. An Example using piecewiseSEM</h2>
<div id="worked-example" class="section level3">
<h3 class="hasAnchor">
<a href="#worked-example" class="anchor"></a>2.1 Worked example</h3>
<p>Let’s make up some fake data corresponding to the path diagram above:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1">dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y2 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y3 =</span> <span class="kw">runif</span>(<span class="dv">50</span>))</a></code></pre></div>
<p>And we will use <code>piecewiseSEM</code> to fit the model. The primary function is <code>psem</code> and we supply the regressions corresponding to the relationships specified in the path diagram, separated by commas as in a <code>list</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># Load required libraries</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">library</span>(piecewiseSEM)</a></code></pre></div>
<pre><code>## 
##   This is piecewiseSEM version 2.0.
## 
##   If you have used the package before, it is strongly recommended you read Section 3 of the vignette('piecewiseSEM') to familiarize yourself with the new syntax.
## 
##   Questions or bugs can be addressed to &lt;jlefcheck@bigelow.org&gt;</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">model &lt;-<span class="st"> </span><span class="kw"><a href="../reference/psem.html">psem</a></span>(<span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>x1, dat), <span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>y2, dat), <span class="kw">lm</span>(y2 <span class="op">~</span><span class="st"> </span>x1, dat), <span class="kw">lm</span>(y3 <span class="op">~</span><span class="st"> </span>y1, dat))</a></code></pre></div>
<pre><code>## Error: Duplicate responses detected in the model list. Collapse into single multiple regression!</code></pre>
<p>You’ll note that this formulation produces an error because we have incorrectly broken down the component regressions. A common mistake is to list each path separately, but the proper specification is to collapse multiple pathways into a single multiple regression if the response is the same. Thus, the properly specified SEM becomes:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">model &lt;-<span class="st"> </span><span class="kw"><a href="../reference/psem.html">psem</a></span>(<span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>y2, dat), <span class="kw">lm</span>(y2 <span class="op">~</span><span class="st"> </span>x1, dat), <span class="kw">lm</span>(y3 <span class="op">~</span><span class="st"> </span>y1, dat))</a></code></pre></div>
<p>To evaluate the model, we call <code>summary</code> on the <code>psem</code> object.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">summary</span>(model, <span class="dt">.progressBar =</span> F)</a></code></pre></div>
<pre><code>## $name
## [1] "model"
## 
## $call
## [1] "y1 ~ x1 + y2\n  y2 ~ x1\n  y3 ~ y1"
## 
## $dTable
##    Independ.Claim Estimate Std.Error DF Crit.Value P.Value 
## 1 y3  ~  x1 + ...  -0.1674    0.1508 47    -1.1102  0.2725 
## 2 y3  ~  y2 + ...   0.1107    0.1329 46     0.8326  0.4094 
## 
## $Cstat
##   Fisher.C df P.Value
## 1    4.386  4   0.356
## 
## $IC
##      AIC   AICc    BIC  K  n
## 1 24.386 31.264 43.506 10 50
## 
## $coefficients
##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1       y1        x1   0.0595    0.1509 47     0.3943  0.6951       0.0591
## 2       y1        y2   0.0831    0.1279 47     0.6499  0.5189       0.0974
## 3       y2        x1   0.3071    0.1644 48     1.8676  0.0679       0.2603
## 4       y3        y1  -0.1405    0.1496 48    -0.9395  0.3522      -0.1344
##   
## 1 
## 2 
## 3 
## 4 
## 
## $R2
##   Response   family     link method R.squared
## 1       y1 gaussian identity   none      0.02
## 2       y2 gaussian identity   none      0.07
## 3       y3 gaussian identity   none      0.02
## 
## attr(,"class")
## [1] "summary.psem"</code></pre>
<p>The output should be familiar to anyone who has evaluated a linear model in R previously.</p>
<p>It shows the call of the model (the component equations), the AIC and BIC scores (derived from that C statistic), and then the tests of directed separation. The last column of the table reports the P-values, which are summarized using the above equation to yield the global goodness-of-fit below. The next table reports the path coefficients, including the standardized values (scaled by standardized deviations). Finally, the individual R-squared values of each regression is given, to aid in evaluation of the model fit.</p>
</div>
<div id="standardized-coefficients" class="section level3">
<h3 class="hasAnchor">
<a href="#standardized-coefficients" class="anchor"></a>2.2 Standardized coefficients</h3>
<p>Standardization of model coefficients is useful for making comparisons about the relative strengths of predictors in a multiple regression. In a network approach, it allows effects to also be compared across multiple responses. Standardized coefficients are also necessary for the calculation of indirect and total effects (because predictors may occur on wildly different scales). Because of their utility, a variety of approaches to coefficient standardization have been proposed, many of which are implemented here.</p>
<div id="the-null-example-no-standardization" class="section level4">
<h4 class="hasAnchor">
<a href="#the-null-example-no-standardization" class="anchor"></a>2.2.1 The null example: no standardization</h4>
<p>Let’s first create an example dataset:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co"># Create fake data.frame</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">coefs.data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="dt">y =</span> <span class="kw">runif</span>(<span class="dv">100</span>),</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="dt">x1 =</span> <span class="kw">runif</span>(<span class="dv">100</span>),</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="dt">x2 =</span> <span class="kw">runif</span>(<span class="dv">100</span>)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="co"># Evaluate linear model</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">model &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x1, coefs.data)</a></code></pre></div>
<p>The function for returning coefficients in <em>piecewiseSEM</em> is <code>coefs</code>.</p>
<p>While standardization is useful, it may be unnecessary or unwanted in certain circumstances. In these cases, one can specify <code>standardize = "none"</code> as an argument to <code>coefs</code>, which will return the raw (unstandardized) coefficients.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw"><a href="../reference/coefs.html">coefs</a></span>(model, <span class="dt">standardize =</span> <span class="st">"none"</span>)</a></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value 
## 1        y        x1   0.0548    0.1049 98     0.5227  0.6024</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co"># These coefficients are identical to those returned by summmary</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">summary</span>(model)<span class="op">$</span>coefficients</a></code></pre></div>
<pre><code>##               Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept) 0.45392310 0.06148272 7.3829379 5.127612e-11
## x1          0.05481277 0.10486865 0.5226802 6.023765e-01</code></pre>
<p>To return the intercepts using <code>coefs</code>, specify the <code>intercepts = TRUE</code> argument:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw"><a href="../reference/coefs.html">coefs</a></span>(model, <span class="dt">standardize =</span> <span class="st">"none"</span>, <span class="dt">intercepts =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>##   Response   Predictor Estimate Std.Error DF Crit.Value P.Value    
## 1        y (Intercept)   0.4539    0.0615 98     7.3829  0.0000 ***
## 2        y          x1   0.0548    0.1049 98     0.5227  0.6024</code></pre>
</div>
<div id="standardization-scaling-by-standard-deviations" class="section level4">
<h4 class="hasAnchor">
<a href="#standardization-scaling-by-standard-deviations" class="anchor"></a>2.2.2 Standardization: scaling by standard deviations</h4>
<p>The most typical implementation of standardization is placing the coefficients in units of standard deviations of the mean. This is accomplished by scaling the coefficients <span class="math inline">\(\beta\)</span> by the ratio of the standard deviation of x over the standard deviation of y:</p>
<p><span class="math display">\[\beta_{std} = \beta*\left( \frac{sd_x}{sd_y} \right)\]</span> We can do this manually for our example dataset:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co"># Obtain the raw coefficient from the coefficient table</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">B &lt;-<span class="st"> </span><span class="kw">summary</span>(model)<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="co"># Compute the standard deviation of the independent variable</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">sd.x &lt;-<span class="st"> </span><span class="kw">sd</span>(coefs.data<span class="op">$</span>x1)</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="co"># Compute the standard deviation of the dependent variable</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">sd.y &lt;-<span class="st"> </span><span class="kw">sd</span>(coefs.data<span class="op">$</span>y)</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="co"># Scale Beta</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">B.sdscaled &lt;-<span class="st"> </span>B <span class="op">*</span><span class="st"> </span>sd.x<span class="op">/</span>sd.y</a></code></pre></div>
<p>The argument for standardization based on standard deviations is <code>standardize = "scale"</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw"><a href="../reference/coefs.html">coefs</a></span>(model, <span class="dt">standardize =</span> <span class="st">"scale"</span>)</a></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y        x1   0.0548    0.1049 98     0.5227  0.6024       0.0527
##   
## 1</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co"># Compare to hand-calculated value</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">B.sdscaled</a></code></pre></div>
<pre><code>## [1] 0.05272524</code></pre>
<p>Note that the <code>coefs</code> function will return both standardized and unstandardized coefficients when specifying any argument other than <code>standardize = "none"</code>.</p>
</div>
<div id="standardization-scaling-by-relevant-ranges" class="section level4">
<h4 class="hasAnchor">
<a href="#standardization-scaling-by-relevant-ranges" class="anchor"></a>2.2.3 Standardization: scaling by relevant ranges</h4>
<p>Instead of scaling by the ratio of the standard deviations, one can scale by the ‘relevant’ range of the data.</p>
<p>The default range standardization considers the full range of variation exhibited by the data. We can again compute the range standardization by hand:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co"># Calculate range for the independent variable</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">range.x &lt;-<span class="st"> </span><span class="kw">diff</span>(<span class="kw">range</span>(coefs.data<span class="op">$</span>x1))</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="co"># Calculate range for the independent variable</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">range.y &lt;-<span class="st"> </span><span class="kw">diff</span>(<span class="kw">range</span>(coefs.data<span class="op">$</span>y))</a>
<a class="sourceLine" id="cb21-6" data-line-number="6"></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="co"># Scale Beta</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">B.range &lt;-<span class="st"> </span>B <span class="op">*</span><span class="st"> </span>range.x<span class="op">/</span>range.y</a></code></pre></div>
<p>The argument for standardization based on ranges is <code>standardize = "range"</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw"><a href="../reference/coefs.html">coefs</a></span>(model, <span class="dt">standardize =</span> <span class="st">"range"</span>)</a></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y        x1   0.0548    0.1049 98     0.5227  0.6024       0.0559
##   
## 1</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co"># Compare to hand-calculated value</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">B.range</a></code></pre></div>
<pre><code>## [1] 0.05594478</code></pre>
<p>If one does not wish to use the full range of the data, and instead restrict the range to a more ‘relevant’ subset of the data, this can be accomplished by providing a named <code>list</code> to the <code>standardize =</code> argument. The names should be <code>x</code> and <code>y</code> and each entry should be a <code>vector</code> of length 2 with the first entry being the minimum and the second entry being the maximum values of the relevant range.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co"># Consider the range 0.1 - 0.8 for x</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">relrange.x &lt;-<span class="st"> </span><span class="fl">0.8-0.1</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="co"># Consider the range 0.3-0.6 for y</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">relrange.y &lt;-<span class="st"> </span><span class="fl">0.6-0.3</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="co"># Scale Beta</span></a>
<a class="sourceLine" id="cb26-8" data-line-number="8">B.relrange &lt;-<span class="st"> </span>B <span class="op">*</span><span class="st"> </span>relrange.x<span class="op">/</span>relrange.y</a>
<a class="sourceLine" id="cb26-9" data-line-number="9"></a>
<a class="sourceLine" id="cb26-10" data-line-number="10"><span class="co"># Compare to automated calculation</span></a>
<a class="sourceLine" id="cb26-11" data-line-number="11"><span class="kw"><a href="../reference/coefs.html">coefs</a></span>(model, <span class="dt">standardize =</span> <span class="kw">list</span>(<span class="dt">x1 =</span> <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">0.8</span>), <span class="dt">y =</span> <span class="kw">c</span>(<span class="fl">0.3</span>, <span class="fl">0.6</span>)))</a></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y        x1   0.0548    0.1049 98     0.5227  0.6024       0.1279
##   
## 1</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1">B.relrange</a></code></pre></div>
<pre><code>## [1] 0.1278965</code></pre>
</div>
<div id="standardization-for-binary-response-models" class="section level4">
<h4 class="hasAnchor">
<a href="#standardization-for-binary-response-models" class="anchor"></a>2.2.4 Standardization for Binary Response Models</h4>
<p>For generalized linear models, the response variables are inherently non-linear. The common solution is to apply a link function to linearize the response, and derive the parameter estimate <span class="math inline">\(\beta\)</span> on this new linear (link) scale. Common link functions include logit and probit for binary responses, and log for Poisson, although many others exist.</p>
<p>This transformation, however, means that the modeled response is not actually observed, and thus the true error is not known. Obtaining the standard deviation of the response used in the calculation of standardized coefficients requires further assumptions about the distribution-specific variance.</p>
<p>We implement two solutions for obtaining the error variance to produce standardized coefficients for GLM, focusing for the moment on binary response models: the latent theoretic (<code>standardize.type = "latent.linear"</code>) and the observation error approach (<code>standardize.type = "Menard.OE"</code>).</p>
<p>In the latent theoretic approach, we assume a fixed error variance for the binomial distribution based on the link function: for logit, it is <span class="math inline">\(\pi\)</span>^2/3 and for the probit, it is 1. This value is added to the predicted fits on the linear (link) scale and then the square-root of the variance of these values is taken to obtain the standard deviation of y.</p>
<p>In the observation error approach, a rough estimate of the error variance is obtained through the calculation of a pseudo-R^2, which is simply the correlation between the observed and predicted fits (in this case, in the original units). The error variance is again added to the variance of the predicted fits and the square-root is taken to obtain the standard deviation of y.</p>
<p>Let’s work through a simple example where we first compute the standardized coefficient by hand, then compare to the output of <code>piecewiseSEM</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="co"># Create fake binomial response</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">coefs.data<span class="op">$</span>y.binom &lt;-<span class="st"> </span><span class="kw">rbinom</span>(<span class="dv">100</span>, <span class="dv">1</span>, <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"></a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="co"># Fit using GLM</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">glm.model &lt;-<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x1, <span class="st">"binomial"</span>, coefs.data)</a>
<a class="sourceLine" id="cb30-6" data-line-number="6"></a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="co"># Extract linear beta</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">Beta.glm &lt;-<span class="st"> </span><span class="kw">summary</span>(glm.model)<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">1</span>]</a></code></pre></div>
<p>And apply the latent theoretic (<code>standardize.type = "latent.linear"</code>) approach:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co"># Extract predicted values on the link scale</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">preds &lt;-<span class="st"> </span><span class="kw">predict</span>(glm.model, <span class="dt">type =</span> <span class="st">"link"</span>)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3"></a>
<a class="sourceLine" id="cb31-4" data-line-number="4"><span class="co"># Compute sd of error variance using theoretical variances</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">sd.y.LT &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(preds) <span class="op">+</span><span class="st"> </span>pi<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb31-6" data-line-number="6"></a>
<a class="sourceLine" id="cb31-7" data-line-number="7"><span class="co"># Compute sd of x</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">sd.x &lt;-<span class="st"> </span><span class="kw">sd</span>(coefs.data<span class="op">$</span>x1)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9"></a>
<a class="sourceLine" id="cb31-10" data-line-number="10"><span class="co"># Compare to automated output</span></a>
<a class="sourceLine" id="cb31-11" data-line-number="11"><span class="kw"><a href="../reference/coefs.html">coefs</a></span>(glm.model, <span class="dt">standardize.type =</span> <span class="st">"latent.linear"</span>)</a></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y        x1   0.2197    0.7586 98     0.2896  0.7722       0.0321
##   
## 1</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1">Beta.glm <span class="op">*</span><span class="st"> </span>sd.x <span class="op">/</span><span class="st"> </span>sd.y.LT</a></code></pre></div>
<pre><code>## [1] 0.0321234</code></pre>
</div>
</div>
<div id="glms-in-psem" class="section level3">
<h3 class="hasAnchor">
<a href="#glms-in-psem" class="anchor"></a>2.3 GLMs in pSEM</h3>
<p>A problematic case arises when intermediate endogenous variables are non-normally distributed. Consider the following SEM:</p>
<div class="figure">
<img src="https://github.com/jslefche/jslefche.github.io/blob/master/img/GLM_sem.jpg?raw=true" alt="2.2 GLM SEM"><p class="caption">2.2 GLM SEM</p>
</div>
<p>In this SEM, there are two independence claims:</p>
<ol style="list-style-type: decimal">
<li><p>y3 | x1 (y1, y2)</p></li>
<li><p>y2 | y1 (x1)</p></li>
</ol>
<p>Considering the second independence claim, in a Gaussian world, the significance value is the same whether the test is conducted as y2 | y1 (x1) or y1 | y2 (x1). This is NOT true, however, when one or both of the variables are modeled using a generalized linear model (GLM) fit to a non-normal distribution. This is because the response is now transformed via the link function (see Section 2.2). This transformations means the P-value obtained by regressing y1 against y2 is NOT the same as the one obtained by regressing y2 against y1.</p>
<p>The following example will show this is the case:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="co"># Generate fake data</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">glmdat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y1 =</span> <span class="kw">rpois</span>(<span class="dv">50</span>, <span class="dv">10</span>), <span class="dt">y2 =</span> <span class="kw">rpois</span>(<span class="dv">50</span>, <span class="dv">50</span>), <span class="dt">y3 =</span> <span class="kw">runif</span>(<span class="dv">50</span>))</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="co"># Extract P-values</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="kw">summary</span>(<span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>y2 <span class="op">+</span><span class="st"> </span>x1, glmdat))<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">4</span>]</a></code></pre></div>
<pre><code>## [1] 0.03378634</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">lm</span>(y2 <span class="op">~</span><span class="st"> </span>y1 <span class="op">+</span><span class="st"> </span>x1, glmdat))<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">4</span>]</a></code></pre></div>
<pre><code>## [1] 0.03378634</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co"># Repeat but model y1 and y2 and Poisson-distributed</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="kw">summary</span>(<span class="kw">glm</span>(y1 <span class="op">~</span><span class="st"> </span>y2 <span class="op">+</span><span class="st"> </span>x1, <span class="st">"poisson"</span>, glmdat))<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">4</span>]</a></code></pre></div>
<pre><code>## [1] 0.04691983</code></pre>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">glm</span>(y2 <span class="op">~</span><span class="st"> </span>y1 <span class="op">+</span><span class="st"> </span>x1, <span class="st">"poisson"</span>, glmdat))<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">4</span>]</a></code></pre></div>
<pre><code>## [1] 0.01278943</code></pre>
<p>This effect is problematic because the d-sep tests are wholly dependent on the significance value. If the P-value is biased based on the direction of the test, then the goodness-of-fit of the model can be over- or underestimated.</p>
<p><code>piecewiseSEM</code> version 2.0 solves this by providing three options to the user.</p>
<ol style="list-style-type: decimal">
<li><p>One can specify the directionality of the test if, for instance, it makes greater biological sense to test <code>y1</code> against <code>y2</code> instead of the reverse.</p></li>
<li><p>One can remove that path from the basis set and instead specify it as a correlated error using <code>%~~%</code>.</p></li>
<li><p>One can conduct both tests and choose the most conservative (i.e., lowest) P-value.</p></li>
</ol>
<p>These options are returned by <code>summary</code> in the event the above scenario is identified in the SEM:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co"># Generate fake data</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2">glmdat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y1 =</span> <span class="kw">rpois</span>(<span class="dv">50</span>, <span class="dv">10</span>), <span class="dt">y2 =</span> <span class="kw">rpois</span>(<span class="dv">50</span>, <span class="dv">50</span>), <span class="dt">y3 =</span> <span class="kw">runif</span>(<span class="dv">50</span>))</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"></a>
<a class="sourceLine" id="cb43-4" data-line-number="4"><span class="co"># Construct SEM</span></a>
<a class="sourceLine" id="cb43-5" data-line-number="5">glmsem &lt;-<span class="st"> </span><span class="kw"><a href="../reference/psem.html">psem</a></span>(</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">  <span class="kw">glm</span>(y1 <span class="op">~</span><span class="st"> </span>x1, <span class="st">"poisson"</span>, glmdat),</a>
<a class="sourceLine" id="cb43-7" data-line-number="7">  <span class="kw">glm</span>(y2 <span class="op">~</span><span class="st"> </span>x1, <span class="st">"poisson"</span>, glmdat),</a>
<a class="sourceLine" id="cb43-8" data-line-number="8">  <span class="kw">lm</span>(y3 <span class="op">~</span><span class="st"> </span>y1 <span class="op">+</span><span class="st"> </span>y2, glmdat)</a>
<a class="sourceLine" id="cb43-9" data-line-number="9">)</a>
<a class="sourceLine" id="cb43-10" data-line-number="10"></a>
<a class="sourceLine" id="cb43-11" data-line-number="11"><span class="kw">summary</span>(glmsem)</a></code></pre></div>
<pre><code>## Error: 
## Non-linearities detected in the basis set where P-values are not symmetrical. 
## This can bias the outcome of the tests of directed separation.
##  
## Offending independence claims: 
##  y2 &lt;- y1 *OR* y2 -&gt; y1 
##  
## Option 1: Specify directionality using argument 'direction = c()' in 'summary'.
##  
## Option 2: Remove path from the basis set by specifying as a correlated error using '%~~%' in 'psem'.
##  
## Option 3 (recommended): Use argument 'conserve = TRUE' in 'summary' to compute both tests, and return the most conservative P-value.</code></pre>
<p>In option 1, the directionality can be specified using <code>direction = c()</code> as an additional argument.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">summary</span>(glmsem, <span class="dt">direction =</span> <span class="kw">c</span>(<span class="st">"y1 &lt;- y2"</span>), <span class="dt">.progressBar =</span> F)<span class="op">$</span>dTable</a></code></pre></div>
<pre><code>##    Independ.Claim Estimate Std.Error DF Crit.Value P.Value 
## 1 y3  ~  x1 + ...  -0.2833    0.1793 46    -1.5798  0.1210 
## 2 y2  ~  y1 + ...   0.0124    0.0080 47     1.5578  0.1193</code></pre>
<p>In option 2, the SEM can be updated to remove that test by specifying it as a correlated error (see Section 2.4).</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">summary</span>(<span class="kw">update</span>(glmsem, y1 <span class="op">%~~%</span><span class="st"> </span>y2), <span class="dt">.progressBar =</span> F)</a></code></pre></div>
<pre><code>## $name
## [1] "update(glmsem, y1 %~~% y2)"
## 
## $call
## [1] "y1 ~ x1\n  y2 ~ x1\n  y3 ~ y1 + y2\n  y1 ~~ y2"
## 
## $dTable
##    Independ.Claim Estimate Std.Error DF Crit.Value P.Value 
## 1 y3  ~  x1 + ...  -0.2833    0.1793 46    -1.5798   0.121 
## 
## $Cstat
##   Fisher.C df P.Value
## 1    4.224  2   0.121
## 
## $IC
##      AIC   AICc   BIC K  n
## 1 20.224 24.663 35.52 8 50
## 
## $coefficients
##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1       y1        x1   0.0930    0.1729 48     0.5378  0.5907           NA
## 2       y2        x1  -0.0540    0.0770 48    -0.7011  0.4832           NA
## 3       y3        y1   0.0092    0.0189 47     0.4896  0.6267       0.0710
## 4       y3        y2  -0.0115    0.0070 47    -1.6577  0.1040      -0.2405
## 5     ~~y1      ~~y2   0.2241        NA 47     1.5766  0.0608       0.2241
##   
## 1 
## 2 
## 3 
## 4 
## 5 
## 
## $R2
##   Response   family     link     method R.squared
## 1       y1  poisson      log nagelkerke      0.01
## 2       y2  poisson      log nagelkerke      0.02
## 3       y3 gaussian identity       none      0.06
## 
## attr(,"class")
## [1] "summary.psem"</code></pre>
<p>Note that the claim no longer appears in the section for the tests of directed separation.</p>
<p>Finally, option 3 can be invoked by specifying <code>conserve = T</code> as an additional argument</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">summary</span>(glmsem, <span class="dt">conserve =</span> T, <span class="dt">.progressBar =</span> F)<span class="op">$</span>dTable</a></code></pre></div>
<pre><code>##    Independ.Claim Estimate Std.Error DF Crit.Value P.Value 
## 1 y3  ~  x1 + ...  -0.2833    0.1793 46    -1.5798  0.1210 
## 2 y2  ~  y1 + ...   0.0124    0.0080 47     1.5578  0.1193</code></pre>
<p>The user should be vigilant for these kinds of situations and ensure that both the specified paths AND the independence claims all make biological sense. In the case where the underlying assumptions of the d-sep tests can bias the goodness-of-fit statistic, <code>piecewiseSEM</code> should automatically alert the user.</p>
</div>
<div id="correlated-errors" class="section level3">
<h3 class="hasAnchor">
<a href="#correlated-errors" class="anchor"></a>2.4 Correlated errors</h3>
<p>Correlated errors reflect the situation where the relationship among the two variables is not presumed to be causal and unidirectional, but rather that both are being driven by some underlying driver and are therefore <em>appear</em> correlated.</p>
<p>Such a relationship is denoted by using a double-headed arrow:</p>
<div class="figure">
<img src="https://github.com/jslefche/jslefche.github.io/blob/master/img/sem_correlated_error.jpg?raw=true" alt="2.4 Correlated error"><p class="caption">2.4 Correlated error</p>
</div>
<p>This behavior is specified in <code>piecewiseSEM</code> using the new operator <code>%~~%</code> in the <code>psem</code> function. We can fit the above SEM:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1">cordat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y2 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y3 =</span> <span class="kw">runif</span>(<span class="dv">50</span>))</a>
<a class="sourceLine" id="cb51-2" data-line-number="2"></a>
<a class="sourceLine" id="cb51-3" data-line-number="3">corsem &lt;-<span class="st"> </span><span class="kw"><a href="../reference/psem.html">psem</a></span>(</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">  <span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>x1, cordat),</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">  <span class="kw">lm</span>(y2 <span class="op">~</span><span class="st"> </span>x1, cordat),</a>
<a class="sourceLine" id="cb51-6" data-line-number="6">  y1 <span class="op">%~~%</span><span class="st"> </span>y2, </a>
<a class="sourceLine" id="cb51-7" data-line-number="7">  <span class="kw">lm</span>(y3 <span class="op">~</span><span class="st"> </span>y1 <span class="op">+</span><span class="st"> </span>y2, cordat)</a>
<a class="sourceLine" id="cb51-8" data-line-number="8">)</a>
<a class="sourceLine" id="cb51-9" data-line-number="9"></a>
<a class="sourceLine" id="cb51-10" data-line-number="10"><span class="kw">summary</span>(corsem, <span class="dt">.progressBar =</span> F)</a></code></pre></div>
<pre><code>## $name
## [1] "corsem"
## 
## $call
## [1] "y1 ~ x1\n  y2 ~ x1\n  y1 ~~ y2\n  y3 ~ y1 + y2"
## 
## $dTable
##    Independ.Claim Estimate Std.Error DF Crit.Value P.Value 
## 1 y3  ~  x1 + ...   0.1572    0.1537 46     1.0227  0.3118 
## 
## $Cstat
##   Fisher.C df P.Value
## 1    2.331  2   0.312
## 
## $IC
##      AIC   AICc    BIC  K  n
## 1 22.331 28.629 41.451 10 50
## 
## $coefficients
##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1       y1        x1  -0.1147    0.1361 48    -0.8430  0.4034      -0.1208
## 2       y2        x1  -0.1798    0.1415 48    -1.2707  0.2100      -0.1804
## 3     ~~y1      ~~y2   0.2122        NA 47     1.4883  0.0717       0.2122
## 4       y3        y1  -0.1137    0.1630 47    -0.6974  0.4890      -0.1023
## 5       y3        y2   0.2109    0.1553 47     1.3578  0.1810       0.1993
##   
## 1 
## 2 
## 3 
## 4 
## 5 
## 
## $R2
##   Response   family     link method R.squared
## 1       y1 gaussian identity   none      0.01
## 2       y2 gaussian identity   none      0.03
## 3       y3 gaussian identity   none      0.04
## 
## attr(,"class")
## [1] "summary.psem"</code></pre>
<p>In the case where the correlated error occurs between two exogenous variables, it is simply the raw bivariate correlation whose P-value is determined using modifications to the function <code>cor.test</code>. In the event the correlated error includes an endogenous variable, it is the partial correlation that removes the effect of any covariates.</p>
<p>In the above example, the correlated error removes the influence of <code>x1</code> on both <code>y1</code> and <code>y2</code> before computing their correlation.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="kw">cor</span>(<span class="kw">resid</span>(<span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>x1, cordat)), <span class="kw">resid</span>(<span class="kw">lm</span>(y2 <span class="op">~</span><span class="st"> </span>x1, cordat)))</a></code></pre></div>
<pre><code>## [1] 0.2121521</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="kw"><a href="../reference/cerror.html">cerror</a></span>(y1 <span class="op">%~~%</span><span class="st"> </span>y2, corsem)</a></code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value
## 1     ~~y1      ~~y2   0.2122        NA 47     1.4883  0.0717</code></pre>
</div>
<div id="nested-models-and-aic" class="section level3">
<h3 class="hasAnchor">
<a href="#nested-models-and-aic" class="anchor"></a>2.5 Nested models and AIC</h3>
<p>As noted, Shipley (2013) used the Fisher’s C statistic to construct an AIC score to facilitate model comparison and selection. This can be accomplished in the <code>piecewiseSEM</code> package with one important distinction.</p>
<p>Let’s consider comparing the following models for the mediating role of <code>y1</code>:</p>
<div class="figure">
<img src="https://github.com/jslefche/jslefche.github.io/blob/master/img/sem_AIC_example.jpg?raw=true" alt="2.5.1 AIC SEM"><p class="caption">2.5.1 AIC SEM</p>
</div>
<p>One might think that the models could be coded like this, and then compared:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb57-1" data-line-number="1">AICdat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y1 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y2 =</span> <span class="kw">runif</span>(<span class="dv">50</span>), <span class="dt">y3 =</span> <span class="kw">runif</span>(<span class="dv">50</span>))</a>
<a class="sourceLine" id="cb57-2" data-line-number="2"></a>
<a class="sourceLine" id="cb57-3" data-line-number="3">sem1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/psem.html">psem</a></span>(</a>
<a class="sourceLine" id="cb57-4" data-line-number="4">  <span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>x1, AICdat),</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">  <span class="kw">lm</span>(y2 <span class="op">~</span><span class="st"> </span>y1, AICdat),</a>
<a class="sourceLine" id="cb57-6" data-line-number="6">  <span class="kw">lm</span>(y3 <span class="op">~</span><span class="st"> </span>y2, AICdat)</a>
<a class="sourceLine" id="cb57-7" data-line-number="7">)</a>
<a class="sourceLine" id="cb57-8" data-line-number="8"></a>
<a class="sourceLine" id="cb57-9" data-line-number="9">sem2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/psem.html">psem</a></span>(</a>
<a class="sourceLine" id="cb57-10" data-line-number="10">  <span class="kw">lm</span>(y1 <span class="op">~</span><span class="st"> </span>x1, AICdat),</a>
<a class="sourceLine" id="cb57-11" data-line-number="11">  <span class="kw">lm</span>(y2 <span class="op">~</span><span class="st"> </span>y1, AICdat)</a>
<a class="sourceLine" id="cb57-12" data-line-number="12">)</a>
<a class="sourceLine" id="cb57-13" data-line-number="13"></a>
<a class="sourceLine" id="cb57-14" data-line-number="14"><span class="kw">AIC</span>(sem1, sem2)</a></code></pre></div>
<p>However, this does not account for the potential missing relationships with <code>y3</code> to be in the model, which is critical as AIC incorporates Fisher’s C, which is determined by the d-sep tests. <code>y3</code> must be present in the d-sep tests to make the comparison fair (i.e., the models must be nested).</p>
<div class="figure">
<img src="https://github.com/jslefche/jslefche.github.io/blob/master/img/sem_AIC_example2.jpg?raw=true" alt="2.5.2 AIC SEM (nested)"><p class="caption">2.5.2 AIC SEM (nested)</p>
</div>
<p>To do so, we can use the following syntax:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1">sem2new &lt;-<span class="st"> </span><span class="kw">update</span>(sem2, y3 <span class="op">~</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb58-2" data-line-number="2"></a>
<a class="sourceLine" id="cb58-3" data-line-number="3"><span class="kw">AIC</span>(sem1, sem2new)</a></code></pre></div>
<pre><code>##   df    AIC
## x  9 21.664
## y  6 15.992</code></pre>
<p>Now the comparison is fair and the model selection procedure is robust. In this case, the models have equivalent support (i.e., <span class="math inline">\(\delta\)</span>AIC &lt; 2).</p>
<p>Comparison of saturated models–ones that have <em>no</em> missing paths–and unsaturated ones using AIC is currently not possible, although we are looking into possible likelihood formulations in the absence of a C statistic.</p>
</div>
</div>
<div id="comparing-package-versions" class="section level2">
<h2 class="hasAnchor">
<a href="#comparing-package-versions" class="anchor"></a>3. Comparing Package Versions</h2>
<p>The new version 2.0 of <code>piecewiseSEM</code> replaces all of the old functions from version 1.x. This section will walk the user through the same worked example included in version 1.x from Shipley (2009), emphasizing the new syntax.</p>
<div id="introduction-to-shipley-2009" class="section level3">
<h3 class="hasAnchor">
<a href="#introduction-to-shipley-2009" class="anchor"></a>3.1 Introduction to Shipley (2009)</h3>
<p>Shipley included an example dataset in his 2009 paper ‘Confirmatory path analysis in a generalized multilevel context.’ The data are included in this version of the package and alternately hosted in Ecological Archives E090-028-S1 (DOI: 10.1890/08-1034.1). While not actual observations (the data are randomly generated), the hypotheses correspond to actual ecological phenomenon.</p>
<p>Briefly, the data concern a forest survey where 5 individual trees of a particular species are followed at 20 sites every year beginning in 1970. For each individual, there is a measurement of: <em>the latitude of the site (<code>lat</code>) </em>the degree days until break (<code>DD</code>) <em>the Julian date (date of year) of bud break (<code>Date</code>) </em>the increase in stem diameter per tree (<code>Growth</code>) *a binary variable indicating whether the tree is alive (1) or dead (0) (<code>Survival</code>)</p>
<p>Shipley notes that this model would be difficult to test using traditional SEM because it represents variation occurring at multiple levels (between sites, between individuals within sites, and between years within individuals within sites), and one response, survival, is not normally distributed.</p>
<p>Shipley hypothesizes that the data adhere to the following hypothesized causal structure:</p>
<div class="figure">
<img src="https://github.com/jslefche/jslefche.github.io/blob/master/img/shipley_sem.jpg?raw=true" alt="3.1 Shipley SEM"><p class="caption">3.1 Shipley SEM</p>
</div>
<p>This example was included as the primary worked dataset in version 1.x of <code>piecewiseSEM</code>.</p>
</div>
<div id="comparing-versions-in-evaluating-the-shipleys-sem" class="section level3">
<h3 class="hasAnchor">
<a href="#comparing-versions-in-evaluating-the-shipleys-sem" class="anchor"></a>3.2 Comparing versions in evaluating the Shipley’s SEM</h3>
<p>In the previous version 1.x of the package, the model is constructed using a <code>list</code> and then supplied to various additional functions to measure fit, extract coefficients, and so on. Version 2.0 of the package uses the new function <code>psem</code> and uses <code>summary</code> to extract all that information at once.</p>
<p>Next, we will walk through the analysis of the Shipley data using version 1.x and version 2.0, and compare the output.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="co"># Load required packages</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"><span class="kw">library</span>(nlme)</a>
<a class="sourceLine" id="cb60-3" data-line-number="3"><span class="kw">library</span>(lme4)</a>
<a class="sourceLine" id="cb60-4" data-line-number="4"></a>
<a class="sourceLine" id="cb60-5" data-line-number="5"><span class="co"># Load Shipley data</span></a>
<a class="sourceLine" id="cb60-6" data-line-number="6"><span class="kw">data</span>(shipley)</a>
<a class="sourceLine" id="cb60-7" data-line-number="7"></a>
<a class="sourceLine" id="cb60-8" data-line-number="8"><span class="co"># Create list of structural equations</span></a>
<a class="sourceLine" id="cb60-9" data-line-number="9">shipley.list &lt;-<span class="st"> </span><span class="kw">list</span>(</a>
<a class="sourceLine" id="cb60-10" data-line-number="10"></a>
<a class="sourceLine" id="cb60-11" data-line-number="11">  <span class="kw"><a href="http://www.rdocumentation.org/packages/nlme/topics/lme">lme</a></span>(DD <span class="op">~</span><span class="st"> </span>lat, <span class="dt">random =</span> <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">|</span><span class="st"> </span>site <span class="op">/</span><span class="st"> </span>tree, <span class="dt">na.action =</span> na.omit, </a>
<a class="sourceLine" id="cb60-12" data-line-number="12">  <span class="dt">data =</span> shipley),</a>
<a class="sourceLine" id="cb60-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb60-14" data-line-number="14">  <span class="kw"><a href="http://www.rdocumentation.org/packages/nlme/topics/lme">lme</a></span>(Date <span class="op">~</span><span class="st"> </span>DD, <span class="dt">random =</span> <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">|</span><span class="st"> </span>site <span class="op">/</span><span class="st"> </span>tree, <span class="dt">na.action =</span> na.omit, </a>
<a class="sourceLine" id="cb60-15" data-line-number="15">  <span class="dt">data =</span> shipley),</a>
<a class="sourceLine" id="cb60-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb60-17" data-line-number="17">  <span class="kw"><a href="http://www.rdocumentation.org/packages/nlme/topics/lme">lme</a></span>(Growth <span class="op">~</span><span class="st"> </span>Date, <span class="dt">random =</span> <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">|</span><span class="st"> </span>site <span class="op">/</span><span class="st"> </span>tree, <span class="dt">na.action =</span> na.omit, </a>
<a class="sourceLine" id="cb60-18" data-line-number="18">  <span class="dt">data =</span> shipley),</a>
<a class="sourceLine" id="cb60-19" data-line-number="19">  </a>
<a class="sourceLine" id="cb60-20" data-line-number="20">  <span class="kw"><a href="http://www.rdocumentation.org/packages/lme4/topics/glmer">glmer</a></span>(Live <span class="op">~</span><span class="st"> </span>Growth <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">|</span><span class="st"> </span>site) <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">|</span><span class="st"> </span>tree), </a>
<a class="sourceLine" id="cb60-21" data-line-number="21">  <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link =</span> <span class="st">"logit"</span>), <span class="dt">data =</span> shipley) </a>
<a class="sourceLine" id="cb60-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb60-23" data-line-number="23">  )</a></code></pre></div>
<p>Note the use of mixed effects models to account for the nested non-independence of replicates as well as the use of a generalized linear mixed effects model to account for the binomial distribution of survival.</p>
<p>Next, we extract the goodness-of-fit and path coefficients.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" data-line-number="1">(old.fit &lt;-<span class="st"> </span><span class="kw"><a href="../reference/sem.fit.html">sem.fit</a></span>(shipley.list, shipley, <span class="dt">.progressBar =</span> F))</a></code></pre></div>
<pre><code>## Warning: `sem.fit` has been replaced. Use `psem` instead of `list`, and
## then call `summary` on that object</code></pre>
<pre><code>## Conditional variables have been omitted from output table for clarity (or use argument conditional = T)</code></pre>
<pre><code>## $missing.paths
##         missing.path estimate std.error   df crit.value p.value 
## 1   Date ~ lat + ...  -0.0091    0.1135   18    -0.0798  0.9373 
## 2 Growth ~ lat + ...  -0.0989    0.1107   18    -0.8929  0.3837 
## 3   Live ~ lat + ...   0.0305    0.0297   NA     1.0281  0.3039 
## 4  Growth ~ DD + ...  -0.0106    0.0358 1329    -0.2967  0.7667 
## 5    Live ~ DD + ...   0.0272    0.0271   NA     1.0042  0.3153 
## 6  Live ~ Date + ...  -0.0466    0.0298   NA    -1.5613  0.1184 
## 
## $Fisher.C
##   fisher.c df p.value
## 1    11.53 12   0.484
## 
## $AIC
##     AIC   AICc  K    n
## 1 49.53 50.069 19 1431</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb65-1" data-line-number="1">(old.coefs &lt;-<span class="st"> </span><span class="kw"><a href="../reference/sem.coefs.html">sem.coefs</a></span>(shipley.list))</a></code></pre></div>
<pre><code>## Warning: `sem.coefs` has been replaced. Use `psem` instead of `list`, and
## then call `summary` or `coefs` on that object</code></pre>
<pre><code>##   response predictor   estimate   std.error p.value    
## 1       DD       lat -0.8354736 0.119422385       0 ***
## 2     Date        DD -0.4976475 0.004933274       0 ***
## 3   Growth      Date  0.3007147 0.026631405       0 ***
## 4     Live    Growth  0.3478536 0.058407891       0 ***</code></pre>
<p>Note the warnings produced by calling the old functions.</p>
<p>Now, we repeat the exercise using the new functions. <code>as.psem</code> converts the list to <code>psem</code> object, but you could also run the code using <code>psem</code> instead of <code>list</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb68-1" data-line-number="1">shipley.psem &lt;-<span class="st"> </span><span class="kw"><a href="../reference/as.psem.html">as.psem</a></span>(shipley.list)</a>
<a class="sourceLine" id="cb68-2" data-line-number="2">### NOT RUN</a>
<a class="sourceLine" id="cb68-3" data-line-number="3"><span class="co"># shipley.psem &lt;- psem(</span></a>
<a class="sourceLine" id="cb68-4" data-line-number="4"><span class="co"># </span></a>
<a class="sourceLine" id="cb68-5" data-line-number="5"><span class="co">#   lme(DD ~ lat, random = ~ 1 | site / tree, na.action = na.omit, </span></a>
<a class="sourceLine" id="cb68-6" data-line-number="6"><span class="co">#   data = shipley),</span></a>
<a class="sourceLine" id="cb68-7" data-line-number="7"><span class="co">#   </span></a>
<a class="sourceLine" id="cb68-8" data-line-number="8"><span class="co">#   lme(Date ~ DD, random = ~ 1 | site / tree, na.action = na.omit, </span></a>
<a class="sourceLine" id="cb68-9" data-line-number="9"><span class="co">#   data = shipley),</span></a>
<a class="sourceLine" id="cb68-10" data-line-number="10"><span class="co">#   </span></a>
<a class="sourceLine" id="cb68-11" data-line-number="11"><span class="co">#   lme(Growth ~ Date, random = ~ 1 | site / tree, na.action = na.omit, </span></a>
<a class="sourceLine" id="cb68-12" data-line-number="12"><span class="co">#   data = shipley),</span></a>
<a class="sourceLine" id="cb68-13" data-line-number="13"><span class="co">#   </span></a>
<a class="sourceLine" id="cb68-14" data-line-number="14"><span class="co">#   glmer(Live ~ Growth + (1 | site) + (1 | tree), </span></a>
<a class="sourceLine" id="cb68-15" data-line-number="15"><span class="co">#   family = binomial(link = "logit"), data = shipley) </span></a>
<a class="sourceLine" id="cb68-16" data-line-number="16"><span class="co">#   </span></a>
<a class="sourceLine" id="cb68-17" data-line-number="17"><span class="co">#   )</span></a></code></pre></div>
<p>Now we extract a summary of the object.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb69-1" data-line-number="1">(new.summary &lt;-<span class="st"> </span><span class="kw">summary</span>(shipley.psem, <span class="dt">.progressBar =</span> F))</a></code></pre></div>
<pre><code>## $name
## [1] "shipley.psem"
## 
## $call
## [1] "DD ~ lat\n  Date ~ DD\n  Growth ~ Date\n  Live ~ Growth"
## 
## $dTable
##         Independ.Claim Estimate Std.Error   DF Crit.Value P.Value 
## 1   Date  ~  lat + ...  -0.0091    0.1135   18    -0.0798  0.9373 
## 2 Growth  ~  lat + ...  -0.0989    0.1107   18    -0.8929  0.3837 
## 3   Live  ~  lat + ...   0.0305    0.0297   NA     1.0281  0.3039 
## 4  Growth  ~  DD + ...  -0.0106    0.0358 1329    -0.2967  0.7667 
## 5    Live  ~  DD + ...   0.0272    0.0271   NA     1.0035  0.3156 
## 6  Live  ~  Date + ...  -0.0466    0.0298   NA    -1.5622  0.1183 
## 
## $Cstat
##   Fisher.C df P.Value
## 1   11.535 12   0.484
## 
## $IC
##      AIC   AICc     BIC  K    n
## 1 49.535 50.237 149.591 19 1431
## 
## $coefficients
##   Response   Predictor Estimate Std.Error   DF Crit.Value P.Value
## 1       DD (Intercept) 196.6524    7.6605 1331    25.6708  0.0000
## 2       DD         lat  -0.8355    0.1194   18    -6.9960  0.0000
## 3     Date (Intercept) 198.3382    1.1842 1330   167.4825  0.0000
## 4     Date          DD  -0.4976    0.0049 1330  -100.8757  0.0000
## 5   Growth (Intercept)  10.7892    3.5189 1330     3.0661  0.0022
## 6   Growth        Date   0.3007    0.0266 1330    11.2917  0.0000
## 7     Live      Growth   0.3479    0.0584 1431     5.9556  0.0000
##   Std.Estimate    
## 1     161.8746 ***
## 2      -0.6877 ***
## 3     250.3448 ***
## 4      -0.6281 ***
## 5      13.7208  **
## 6       0.3824 ***
## 7           NA ***
## 
## $R2
##   Response   family     link method Marginal Conditional
## 1       DD gaussian identity   none     0.49        0.70
## 2     Date gaussian identity   none     0.41        0.98
## 3   Growth gaussian identity   none     0.11        0.84
## 4     Live binomial    logit  delta     0.16        0.18
## 
## attr(,"class")
## [1] "summary.psem"</code></pre>
<p>The output will look familiar to anyone who has run a regression in R.</p>
<p>First, we have the call, which represents the structural questions.</p>
<p>Next are the AIC and new BIC values, formerly accessible using <code>sem.aic</code>. The two produce identical values.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb71-1" data-line-number="1"><span class="co"># Old function</span></a>
<a class="sourceLine" id="cb71-2" data-line-number="2"><span class="kw"><a href="../reference/sem.aic.html">sem.aic</a></span>(shipley.list, shipley, <span class="dt">.progressBar =</span> F)<span class="op">$</span>AIC</a></code></pre></div>
<pre><code>## [1] 49.53</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="co"># Extract from new summary object</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2">new.summary<span class="op">$</span>IC<span class="op">$</span>AIC</a></code></pre></div>
<pre><code>## [1] 49.535</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb75-1" data-line-number="1">### NOT RUN</a>
<a class="sourceLine" id="cb75-2" data-line-number="2"><span class="co"># Alternately, one could call AIC() on the `psem` object</span></a>
<a class="sourceLine" id="cb75-3" data-line-number="3"><span class="co"># AIC(shipley.psem)</span></a></code></pre></div>
<p>Note that because the values are stored in the summary output, they are much quicker to access than having to recompute the d-sep tests using <code>sem.aic</code>.</p>
<p>Following the information criterion values, we have the tests of directed separation. As in the previous version, the independence claims are truncated to remove the conditioning variables (they can be shown using the argument <code>conditional = TRUE</code>).</p>
<p>The d-sep tests are, once again, identical between the two versions, but are faster to retrieve from <code>summary</code> than recomputing them from scratch.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb76-1" data-line-number="1"><span class="co"># Old function</span></a>
<a class="sourceLine" id="cb76-2" data-line-number="2"><span class="kw"><a href="../reference/sem.missing.paths.html">sem.missing.paths</a></span>(shipley.list, shipley, <span class="dt">.progressBar =</span> F)</a></code></pre></div>
<pre><code>## Conditional variables have been omitted from output table for clarity (or use argument conditional = T)</code></pre>
<pre><code>##         missing.path     estimate  std.error   df  crit.value   p.value 
## 1   Date ~ lat + ... -0.009051378 0.11347661   18 -0.07976426 0.9373049 
## 2 Growth ~ lat + ... -0.098862826 0.11072020   18 -0.89290690 0.3836896 
## 3   Live ~ lat + ...  0.030496786 0.02966350   NA  1.02809131 0.3039069 
## 4  Growth ~ DD + ... -0.010613707 0.03576722 1329 -0.29674399 0.7667083 
## 5    Live ~ DD + ...  0.027190372 0.02707564   NA  1.00423751 0.3152641 
## 6  Live ~ Date + ... -0.046565402 0.02982419   NA -1.56133000 0.1184459</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="co"># Extract from new summary object</span></a>
<a class="sourceLine" id="cb79-2" data-line-number="2">new.summary<span class="op">$</span>dTable</a></code></pre></div>
<pre><code>##         Independ.Claim Estimate Std.Error   DF Crit.Value P.Value 
## 1   Date  ~  lat + ...  -0.0091    0.1135   18    -0.0798  0.9373 
## 2 Growth  ~  lat + ...  -0.0989    0.1107   18    -0.8929  0.3837 
## 3   Live  ~  lat + ...   0.0305    0.0297   NA     1.0281  0.3039 
## 4  Growth  ~  DD + ...  -0.0106    0.0358 1329    -0.2967  0.7667 
## 5    Live  ~  DD + ...   0.0272    0.0271   NA     1.0035  0.3156 
## 6  Live  ~  Date + ...  -0.0466    0.0298   NA    -1.5622  0.1183</code></pre>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb81-1" data-line-number="1">### NOT RUN</a>
<a class="sourceLine" id="cb81-2" data-line-number="2"><span class="co"># Alternately, one could call dSep() on the `psem` object</span></a>
<a class="sourceLine" id="cb81-3" data-line-number="3"><span class="co"># dSep(shipley.psem)</span></a></code></pre></div>
<p>After the d-sep table is the Fisher’s C statistic, and the results from the <span class="math inline">\(\chi^2\)</span> test. This information was formerly obtained from <code>sem.fit</code>.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb82-1" data-line-number="1"><span class="co"># Old function</span></a>
<a class="sourceLine" id="cb82-2" data-line-number="2"><span class="kw"><a href="../reference/sem.fit.html">sem.fit</a></span>(shipley.list, shipley, <span class="dt">.progressBar =</span> F)<span class="op">$</span>Fisher.C</a></code></pre></div>
<pre><code>## Warning: `sem.fit` has been replaced. Use `psem` instead of `list`, and
## then call `summary` on that object</code></pre>
<pre><code>## Conditional variables have been omitted from output table for clarity (or use argument conditional = T)</code></pre>
<pre><code>##   fisher.c df p.value
## 1    11.53 12   0.484</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb86-1" data-line-number="1"><span class="co"># Extract from summary object</span></a>
<a class="sourceLine" id="cb86-2" data-line-number="2">new.summary<span class="op">$</span>Cstat</a></code></pre></div>
<pre><code>##   Fisher.C df P.Value
## 1   11.535 12   0.484</code></pre>
<p>As with all other functions, the values are exactly the same although the underlying functions have been rewritten to be more efficient.</p>
<p>Next, we have the path coefficients and the standardized estimates.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb88-1" data-line-number="1"><span class="co"># Old function</span></a>
<a class="sourceLine" id="cb88-2" data-line-number="2"><span class="kw"><a href="../reference/sem.coefs.html">sem.coefs</a></span>(shipley.list, shipley)</a></code></pre></div>
<pre><code>## Warning: `sem.coefs` has been replaced. Use `psem` instead of `list`, and
## then call `summary` or `coefs` on that object</code></pre>
<pre><code>##   response predictor   estimate   std.error p.value    
## 1       DD       lat -0.8354736 0.119422385       0 ***
## 2     Date        DD -0.4976475 0.004933274       0 ***
## 3   Growth      Date  0.3007147 0.026631405       0 ***
## 4     Live    Growth  0.3478536 0.058407891       0 ***</code></pre>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb91-1" data-line-number="1"><span class="kw"><a href="../reference/sem.coefs.html">sem.coefs</a></span>(shipley.list, shipley, <span class="dt">standardize =</span> <span class="st">"scale"</span>)</a></code></pre></div>
<pre><code>## Warning: `sem.coefs` has been replaced. Use `psem` instead of `list`, and
## then call `summary` or `coefs` on that object</code></pre>
<pre><code>## Warning in get.scaled.data(modelList, data, standardize): One or more
## responses not modeled to a normal distribution: keeping response(s) on
## original scale!</code></pre>
<pre><code>##   response predictor   estimate   std.error p.value    
## 1       DD       lat -0.7014051 0.100258794       0 ***
## 2     Date        DD -0.6281367 0.006226838       0 ***
## 3   Growth      Date  0.3824224 0.033867469       0 ***
## 4     Live    Growth  2.2268596 0.373932623       0 ***</code></pre>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb95-1" data-line-number="1"><span class="co"># Extract from new summary object</span></a>
<a class="sourceLine" id="cb95-2" data-line-number="2">new.summary<span class="op">$</span>coefficients</a></code></pre></div>
<pre><code>##   Response   Predictor Estimate Std.Error   DF Crit.Value P.Value
## 1       DD (Intercept) 196.6524    7.6605 1331    25.6708  0.0000
## 2       DD         lat  -0.8355    0.1194   18    -6.9960  0.0000
## 3     Date (Intercept) 198.3382    1.1842 1330   167.4825  0.0000
## 4     Date          DD  -0.4976    0.0049 1330  -100.8757  0.0000
## 5   Growth (Intercept)  10.7892    3.5189 1330     3.0661  0.0022
## 6   Growth        Date   0.3007    0.0266 1330    11.2917  0.0000
## 7     Live      Growth   0.3479    0.0584 1431     5.9556  0.0000
##   Std.Estimate    
## 1     161.8746 ***
## 2      -0.6877 ***
## 3     250.3448 ***
## 4      -0.6281 ***
## 5      13.7208  **
## 6       0.3824 ***
## 7           NA ***</code></pre>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" data-line-number="1"><span class="co"># The new coefs() function is much faster too</span></a>
<a class="sourceLine" id="cb97-2" data-line-number="2"><span class="kw"><a href="../reference/coefs.html">coefs</a></span>(shipley.psem)</a></code></pre></div>
<pre><code>##   Response   Predictor Estimate Std.Error   DF Crit.Value P.Value
## 1       DD (Intercept) 196.6524    7.6605 1331    25.6708  0.0000
## 2       DD         lat  -0.8355    0.1194   18    -6.9960  0.0000
## 3     Date (Intercept) 198.3382    1.1842 1330   167.4825  0.0000
## 4     Date          DD  -0.4976    0.0049 1330  -100.8757  0.0000
## 5   Growth (Intercept)  10.7892    3.5189 1330     3.0661  0.0022
## 6   Growth        Date   0.3007    0.0266 1330    11.2917  0.0000
## 7     Live      Growth   0.3479    0.0584 1431     5.9556  0.0000
##   Std.Estimate    
## 1     161.8746 ***
## 2      -0.6877 ***
## 3     250.3448 ***
## 4      -0.6281 ***
## 5      13.7208  **
## 6       0.3824 ***
## 7           NA ***</code></pre>
<p>Note two items: <em>the standardized estimates and their standard errors are now reported by default at the end of the coefficients table (column <code>Std.Estimate</code>). </em>the standardized estimate for the logistic regression is different, based on new calculations (see Section 2.2)</p>
<p>For the moment, version 2.0 only reports the scaled estimates (based on the standard deviations of the response and predictor). Future versions will include a range standardization.</p>
<p>Finally, <code>summary</code> reports the individual model R<sup>2</sup> values. These were formerly obtained using <code>sem.model.fits</code> which was confusing. I have not included the old calculations in the package as the new <code>rsquared</code> function includes new calculations. However, this information is useful and therefore is now reported alongside the d-sep tests, Fisher’s C, and path coefficients.</p>
</div>
<div id="additional-functions" class="section level3">
<h3 class="hasAnchor">
<a href="#additional-functions" class="anchor"></a>3.3 Additional functions</h3>
<p>The function <code>partial.resid</code> has been replaced with <code>partialResid</code> although the syntax is the same. The plotting output, however, has been eliminated.</p>
<p><code>partialResid</code> extracts the partial effects of <code>y ~ x</code> in a multiple regression <code>y ~ x + Z</code>. For example:</p>
<pre><code># Generate data
dat &lt;- data.frame(y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100))

# Build model
model &lt;- lm(y ~ x1 + x2, dat)

# Compute partial residuals of y ~ x1
yresid &lt;- resid(lm(y ~ x2, dat))

xresid &lt;- resid(lm(x1 ~ x2, dat))

# Use partialResid
presid &lt;- partialResid(y ~ x1, model)

par(mfrow = c(1, 2))

plot(yresid, xresid)

plot(presid) # identical plot!</code></pre>
<p><code>sem.lavaan</code> has not yet been ported to version 2.0, and it may not, as there was some confusion how multi-level models were translated to the variance-covariance framework (hint: they weren’t, only the formulae were transferred).</p>
<p><code>sem.plot</code> has also not yet been ported to version 2.0, since it was of limited utility. It may make an appearance in the future.</p>
</div>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>4. References</h2>
<p>Shipley, Bill. “A new inferential test for path models based on directed acyclic graphs.” Structural Equation Modeling 7.2 (2000): 206-218.</p>
<p>Shipley, Bill. Cause and correlation in biology: a user’s guide to path analysis, structural equations and causal inference. Cambridge University Press, 2002.</p>
<p>Shipley, Bill. “Confirmatory path analysis in a generalized multilevel context.” Ecology 90.2 (2009): 363-368.</p>
<p>Shipley, Bill. “The AIC model selection method applied to path analytic models compared using a d-separation test.” Ecology 94.3 (2013): 560-564.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#an-introduction-to-structural-equation-modeling">1. An Introduction to Structural Equation Modeling</a></li>
      <li><a href="#an-example-using-piecewisesem">2. An Example using piecewiseSEM</a></li>
      <li><a href="#comparing-package-versions">3. Comparing Package Versions</a></li>
      <li><a href="#references">4. References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Lefcheck J Lefcheck, Byrnes J Byrnes, Grace J Grace.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
